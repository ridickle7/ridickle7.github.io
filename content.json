{"pages":[],"posts":[{"title":"Algorithm 개인공부 1일차","permalink":"https://riflockle7.github.io/2019/06/17/Algorithm-개인공부-1일차/","excerpt":"","text":"1. 서론 뭐 말할게 있나… 잊어버리지 않기 위해 포스팅한다 :) curricurum은 나동빈 님의 알고리즘 강의대로 진행 작성하신 C코드를 Java 또는 kotlin으로 바꿔가면서 진행 매일프로그래밍 문제도 하나씩 포스팅 예정 2. 3대 기본 정렬 선택정렬 / 버블정렬 / 삽입정렬 1. 선택정렬 말 그대로 선택하는 정렬이다 가장 작은 (or 큰) 값을 선택하여 앞으로 배치 시간복잡도 O(N^2) 12345678910111213141516171819202122232425262728293031323334353637383940public class _01_select &#123; public static void main(String[] args) &#123; int[] arr = new int[10]; for (int i = 0; i &lt; arr.length; i++) &#123; arr[i] = (int) (Math.random() * 100); &#125; print(arr); select(arr); print(arr); &#125; private static void select(int[] arr) &#123; int minIndex; for (int i = 0; i &lt; arr.length; i++) &#123; // 1. 가장 작은 index를 가리킴 minIndex = i; for (int j = i; j &lt; arr.length; j++) &#123; // 2. 더 작은 value를 찾을 경우 해당 index 갱신 if (arr[minIndex] &gt; arr[j]) &#123; minIndex = j; &#125; &#125; // 3. swap int temp = arr[i]; arr[i] = arr[minIndex]; arr[minIndex] = temp; &#125; &#125; public static void print(int[] arr) &#123; for (int value : arr) &#123; System.out.print(value + \" \"); &#125; System.out.println(); &#125;&#125; 2. 버블정렬 가장 구현이 간단하지만 그 만큼 비효율적인 알고리즘 바로 옆과 값을 비교하여 가장 큰 (작은) 값을 앞으로 보냄 시간복잡도 O(N^2) 123456789101112131415161718192021222324252627282930public class _02_bubble &#123; public static void main(String[] args) &#123; int[] arr = new int[10]; for (int i = 0; i &lt; arr.length; i++) &#123; arr[i] = (int) (Math.random() * 100); &#125; print(arr); bubble(arr); print(arr); &#125; private static void bubble(int[] arr) &#123; for (int i = 0; i &lt; arr.length - 1; i++) &#123; // 1. 바로 오른쪽과 비교하여 작은 값을 왼쪽으로 보냄 if (arr[i] &gt; arr[i + 1]) &#123; int temp = arr[i]; arr[i] = arr[i + 1]; arr[i + 1] = temp; &#125; &#125; &#125; public static void print(int[] arr) &#123; for (int value : arr) &#123; System.out.print(value + \" \"); &#125; System.out.println(); &#125;&#125; 3. 삽입정렬 0번쨰 인덱스부터 순차적으로, 각 숫자를 적절한 위치에 삽입한다. 시간복잡도 O(N^2) 12345678910111213141516171819202122232425262728293031323334public class _03_insert &#123; public static void main(String[] args) &#123; int[] arr = new int[10]; for (int i = 0; i &lt; arr.length; i++) &#123; arr[i] = (int) (Math.random() * 100); &#125; print(arr); insert(arr); print(arr); &#125; private static void insert(int[] arr) &#123; // 1. 처음부터 끝까지 실행 for (int i = 0; i &lt; arr.length - 1; i++) &#123; int j = i; // 2. i에서부터 0까지의 모든 값을 확인하여 사잇값에 삽입 while (j &gt;= 0 &amp;&amp; arr[j] &gt; arr[j + 1]) &#123; int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; j--; &#125; &#125; &#125; public static void print(int[] arr) &#123; for (int value : arr) &#123; System.out.print(value + \" \"); &#125; System.out.println(); &#125;&#125; 4. 퀵 정렬 처음 pivot 값을 정한다. (5) 8 7 6 4 3 2 그 값에 따라 왼쪽에서 그 pivot 값보다 큰 값을 찾고 오른쪽에서 그 pivot 값보다 작은 값을 찾는다. (5) 8 7 6 4 3 2 pivot보다 작은 값이, pivot보다 큰 값을 역행하지 않는 경우 값을 바꿔준다. (반복한다) (5) 2 7 6 4 3 8(5) 2 3 6 4 7 8(5) 2 3 4 6 7 8 역행할 시 pivot보다 작은 값을 pivot과 위치를 바꾼다. (5) 2 3 4 6 7 84 2 3 (5) 6 7 8 기본 pivot은 픽스하고 맨 앞의 숫자부터 같은 과정을 반복한다. (4) 2 3 5 6 7 8(3) 2 4 5 6 7 8(2) 3 4 5 6 7 82 3 4 5 (6) 7 82 3 4 5 6 (7) 82 3 4 5 6 7 (8)2 3 4 5 6 7 8 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960 public class _04_quick &#123; public static void main(String[] args) &#123; int[] arr = new int[10]; for (int i = 0; i &lt; arr.length; i++) &#123; arr[i] = (int) (Math.random() * 100); &#125; print(arr); quick(arr, 0, arr.length - 1); print(arr); &#125; private static void quick(int[] arr, int left, int right) &#123; if (left &gt;= right) &#123; return; &#125; // pivot을 하나 정한다. int pivot = left; int leftIndex = left + 1; int rightIndex = right; // 그 pivot 을 기준으로 다음 값에서부터 right까지 범위의 while문을 돌린다 while (leftIndex &lt;= rightIndex) &#123; // 왼쪽에서부터 pivot보다 크거나 같은 값을 찾는다. while (leftIndex &lt;= right &amp;&amp; arr[leftIndex] &lt;= arr[pivot]) leftIndex++; // 오른쪽에서부터 pivot보다 작은 값을 찾는다. while (rightIndex &gt; left &amp;&amp; arr[rightIndex] &gt;= arr[pivot]) &#123; rightIndex--; &#125; // 만약 rightIndex가 leftIndex보다 왼쪽에 있는 경우 rightIndex와 pivot을 바꿔준다 if (leftIndex &gt; rightIndex) &#123; int temp = arr[pivot]; arr[pivot] = arr[rightIndex]; arr[rightIndex] = temp; &#125; // 아닐 경우 leftIndex와 rightIndex의 값을 바꿔준다. else &#123; int temp = arr[leftIndex]; arr[leftIndex] = arr[rightIndex]; arr[rightIndex] = temp; &#125; &#125; quick(arr, left, rightIndex - 1); quick(arr, rightIndex + 1, right); &#125; public static void print(int[] arr) &#123; for (int value : arr) &#123; System.out.print(value + \" \"); &#125; System.out.println(); &#125;&#125;"},{"title":"Hello World","permalink":"https://riflockle7.github.io/2018/10/12/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment add Read more1add &lt;!-- more --&gt; in .md File More info: Read more","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment add Read more1add &lt;!-- more --&gt; in .md File More info: Read more"}]}